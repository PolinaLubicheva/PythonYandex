{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Задание A\n",
    "class Point:\n",
    "    def __init__(self, x, y):\n",
    "        self.x = x\n",
    "        self.y = y\n",
    "\n",
    "    def move(self, shift_x, shift_y):\n",
    "        self.x += shift_x\n",
    "        self.y += shift_y\n",
    "\n",
    "    def length(self, p):\n",
    "        return round(((self.x - p.x)**2 + (self.y - p.y)**2)**0.5, 2)\n",
    "\n",
    "\n",
    "class PatchedPoint(Point):\n",
    "    def __init__(self, *args):\n",
    "        if not args:\n",
    "            self.x, self.y = 0, 0\n",
    "        elif len(args) == 1:\n",
    "            self.x, self.y = args[0]\n",
    "        else:\n",
    "            self.x, self.y = args  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Задание B\n",
    "class Point:\n",
    "    def __init__(self, x, y):\n",
    "        self.x = x\n",
    "        self.y = y\n",
    "\n",
    "    def move(self, shift_x, shift_y):\n",
    "        self.x += shift_x\n",
    "        self.y += shift_y\n",
    "\n",
    "    def length(self, p):\n",
    "        return round(((self.x - p.x)**2 + (self.y - p.y)**2)**0.5, 2)\n",
    "\n",
    "\n",
    "class PatchedPoint(Point):\n",
    "\n",
    "    def __init__(self, *args):\n",
    "        if not args:\n",
    "            self.x, self.y = 0, 0\n",
    "        elif len(args) == 1:\n",
    "            self.x, self.y = args[0]\n",
    "        else:\n",
    "            self.x, self.y = args\n",
    "\n",
    "    def __str__(self):\n",
    "        return f\"({self.x}, {self.y})\"\n",
    "\n",
    "    def __repr__(self):\n",
    "        return f\"PatchedPoint({self.x}, {self.y})\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Задание C\n",
    "class Point:\n",
    "    def __init__(self, x, y):\n",
    "        self.x = x\n",
    "        self.y = y\n",
    "\n",
    "    def move(self, shift_x, shift_y):\n",
    "        self.x += shift_x\n",
    "        self.y += shift_y\n",
    "\n",
    "    def length(self, p):\n",
    "        return round(((self.x - p.x)**2 + (self.y - p.y)**2)**0.5, 2)\n",
    "\n",
    "\n",
    "class PatchedPoint(Point):\n",
    "    def __init__(self, *args):\n",
    "        if not args:\n",
    "            self.x, self.y = 0, 0\n",
    "        elif len(args) == 1:\n",
    "            self.x, self.y = args[0]\n",
    "        else:\n",
    "            self.x, self.y = args\n",
    "\n",
    "    def __str__(self):\n",
    "        return f\"({self.x}, {self.y})\"\n",
    "\n",
    "    def __repr__(self):\n",
    "        return f\"PatchedPoint({self.x}, {self.y})\"\n",
    "\n",
    "    def __add__(self, other):\n",
    "        return PatchedPoint(self.x + other[0], self.y + other[1])\n",
    "\n",
    "    def __iadd__(self, other):\n",
    "        self.move(other[0], other[1])\n",
    "        return self"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Задание D\n",
    "class Fraction:\n",
    "\n",
    "    def __simp(self, coords):\n",
    "        a, b = coords[0], coords[1]\n",
    "        while b:\n",
    "            a, b = b, a % b\n",
    "        return coords[0] // a, coords[1] // a\n",
    "\n",
    "    def __init__(self, *args):\n",
    "        if isinstance(args[0], str):\n",
    "            self.n, self.d = self.__simp(tuple(map(int, args[0].split('/'))))\n",
    "        else:\n",
    "            self.n, self.d = self.__simp(args)\n",
    "\n",
    "    def numerator(self, number=0):\n",
    "        if number:\n",
    "            self.n, self.d = self.__simp((number, self.d))\n",
    "        return self.n\n",
    "\n",
    "    def denominator(self, number=0):\n",
    "        if number:\n",
    "            self.n, self.d = self.__simp((self.n, number))\n",
    "        return self.d\n",
    "\n",
    "    def __str__(self):\n",
    "        return f\"{self.n}/{self.d}\"\n",
    "\n",
    "    def __repr__(self):\n",
    "        return f\"Fraction({self.n}, {self.d})\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Задание E\n",
    "class Fraction:\n",
    "\n",
    "    def __simp(self, coords):\n",
    "        a, b = coords[0], coords[1]\n",
    "        while b:\n",
    "            a, b = b, a % b\n",
    "        return coords[0] // a, coords[1] // a\n",
    "\n",
    "    def __init__(self, *args):\n",
    "        if isinstance(args[0], str):\n",
    "            self.n, self.d = self.__simp(tuple(map(int, args[0].split('/'))))\n",
    "        else:\n",
    "            self.n, self.d = self.__simp(args)\n",
    "\n",
    "    def numerator(self, number=0):\n",
    "        if number:\n",
    "            if self.n > 0:\n",
    "                self.n, self.d = self.__simp((abs(number), self.d))\n",
    "                self.n = -self.n if number < 0 else self.n\n",
    "            elif self.n < 0:\n",
    "                self.n, self.d = self.__simp((abs(number), self.d))\n",
    "                self.n = -self.n if number > 0 else self.n\n",
    "        return abs(self.n)\n",
    "\n",
    "    def denominator(self, number=0):\n",
    "        if number:\n",
    "            if self.n > 0:\n",
    "                self.n, self.d = self.__simp((self.n, abs(number)))\n",
    "                self.n = -self.n if number < 0 else self.n\n",
    "            elif self.n < 0:\n",
    "                self.n, self.d = self.__simp((abs(self.n), abs(number)))\n",
    "                self.n = -self.n if number > 0 else self.n\n",
    "        return self.d\n",
    "\n",
    "    def __neg__(self):\n",
    "        return Fraction(-self.n, self.d)\n",
    "\n",
    "    def __str__(self):\n",
    "        return f\"{self.n}/{self.d}\"\n",
    "\n",
    "    def __repr__(self):\n",
    "        return f\"Fraction('{self.n}/{self.d}')\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Задание F\n",
    "class Fraction:\n",
    "\n",
    "    def __simp(self, coords):\n",
    "        a, b = coords[0], coords[1]\n",
    "        while b:\n",
    "            a, b = b, a % b\n",
    "        return coords[0] // a, coords[1] // a\n",
    "\n",
    "    def __init__(self, *args):\n",
    "        if isinstance(args[0], str):\n",
    "            self.n, self.d = self.__simp(tuple(map(int, args[0].split('/'))))\n",
    "        else:\n",
    "            self.n, self.d = self.__simp(args)\n",
    "\n",
    "    def numerator(self, number=0):\n",
    "        if number:\n",
    "            if self.n > 0:\n",
    "                self.n, self.d = self.__simp((abs(number), self.d))\n",
    "                self.n = -self.n if number < 0 else self.n\n",
    "            elif self.n < 0:\n",
    "                self.n, self.d = self.__simp((abs(number), self.d))\n",
    "                self.n = -self.n if number > 0 else self.n\n",
    "        return abs(self.n)\n",
    "\n",
    "    def denominator(self, number=0):\n",
    "        if number:\n",
    "            if self.n > 0:\n",
    "                self.n, self.d = self.__simp((self.n, abs(number)))\n",
    "                self.n = -self.n if number < 0 else self.n\n",
    "            elif self.n < 0:\n",
    "                self.n, self.d = self.__simp((abs(self.n), abs(number)))\n",
    "                self.n = -self.n if number > 0 else self.n\n",
    "        return self.d\n",
    "\n",
    "    def __neg__(self):\n",
    "        return Fraction(-self.n, self.d)\n",
    "\n",
    "    def __add__(self, other):\n",
    "        return Fraction(self.n * other.d + other.n * self.d, self.d * other.d)\n",
    "\n",
    "    def __iadd__(self, other):\n",
    "        self.n, self.d = self.__simp((self.n * other.d + other.n * self.d, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __sub__(self, other):\n",
    "        return Fraction(self.n * other.d - other.n * self.d, self.d * other.d)\n",
    "\n",
    "    def __isub__(self, other):\n",
    "        self.n, self.d = self.__simp((self.n * other.d - other.n * self.d, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __str__(self):\n",
    "        return f\"{self.n}/{self.d}\"\n",
    "\n",
    "    def __repr__(self):\n",
    "        return f\"Fraction('{self.n}/{self.d}')\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Задание G\n",
    "class Fraction:\n",
    "\n",
    "    def __simp(self, coords):\n",
    "        a, b = coords[0], coords[1]\n",
    "        while b:\n",
    "            a, b = b, a % b\n",
    "        return coords[0] // a, coords[1] // a\n",
    "\n",
    "    def __init__(self, *args):\n",
    "        if isinstance(args[0], str):\n",
    "            self.n, self.d = self.__simp(tuple(map(int, args[0].split('/'))))\n",
    "        else:\n",
    "            self.n, self.d = self.__simp(args)\n",
    "\n",
    "    def numerator(self, number=0):\n",
    "        if number:\n",
    "            if self.n > 0:\n",
    "                self.n, self.d = self.__simp((abs(number), self.d))\n",
    "                self.n = -self.n if number < 0 else self.n\n",
    "            elif self.n < 0:\n",
    "                self.n, self.d = self.__simp((abs(number), self.d))\n",
    "                self.n = -self.n if number > 0 else self.n\n",
    "        return abs(self.n)\n",
    "\n",
    "    def denominator(self, number=0):\n",
    "        if number:\n",
    "            if self.n > 0:\n",
    "                self.n, self.d = self.__simp((self.n, abs(number)))\n",
    "                self.n = -self.n if number < 0 else self.n\n",
    "            elif self.n < 0:\n",
    "                self.n, self.d = self.__simp((abs(self.n), abs(number)))\n",
    "                self.n = -self.n if number > 0 else self.n\n",
    "        return self.d\n",
    "\n",
    "    def __neg__(self):\n",
    "        return Fraction(-self.n, self.d)\n",
    "\n",
    "    def __add__(self, other):\n",
    "        return Fraction(self.n * other.d + other.n * self.d, self.d * other.d)\n",
    "\n",
    "    def __iadd__(self, other):\n",
    "        self.n, self.d = self.__simp((self.n * other.d + other.n * self.d, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __sub__(self, other):\n",
    "        return Fraction(self.n * other.d - other.n * self.d, self.d * other.d)\n",
    "\n",
    "    def __isub__(self, other):\n",
    "        self.n, self.d = self.__simp((self.n * other.d - other.n * self.d, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __mul__(self, other):\n",
    "        return Fraction(self.n * other.n, self.d * other.d)\n",
    "\n",
    "    def __imul__(self, other):\n",
    "        self.n, self.d = self.__simp((self.n * other.n, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __truediv__(self, other):\n",
    "        return Fraction(self.n * other.d, self.d * other.n)\n",
    "\n",
    "    def __itruediv__(self, other):\n",
    "        self.n, self.d = self.__simp((self.n * other.d, self.d * other.n))\n",
    "        return self\n",
    "\n",
    "    def reverse(self):\n",
    "        self.n, self.d = self.__simp((self.d, self.n))\n",
    "        return self\n",
    "\n",
    "    def __str__(self):\n",
    "        return f\"{self.n}/{self.d}\"\n",
    "\n",
    "    def __repr__(self):\n",
    "        return f\"Fraction('{self.n}/{self.d}')\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Задание H\n",
    "class Fraction:\n",
    "\n",
    "    def __simp(self, coords):\n",
    "        a, b = coords[0], coords[1]\n",
    "        while b:\n",
    "            a, b = b, a % b\n",
    "        return coords[0] // a, coords[1] // a\n",
    "\n",
    "    def __init__(self, *args):\n",
    "        if isinstance(args[0], str):\n",
    "            self.n, self.d = self.__simp(tuple(map(int, args[0].split('/'))))\n",
    "        else:\n",
    "            self.n, self.d = self.__simp(args)\n",
    "\n",
    "    def numerator(self, number=0):\n",
    "        if number:\n",
    "            if self.n > 0:\n",
    "                self.n, self.d = self.__simp((abs(number), self.d))\n",
    "                self.n = -self.n if number < 0 else self.n\n",
    "            elif self.n < 0:\n",
    "                self.n, self.d = self.__simp((abs(number), self.d))\n",
    "                self.n = -self.n if number > 0 else self.n\n",
    "        return abs(self.n)\n",
    "\n",
    "    def denominator(self, number=0):\n",
    "        if number:\n",
    "            if self.n > 0:\n",
    "                self.n, self.d = self.__simp((self.n, abs(number)))\n",
    "                self.n = -self.n if number < 0 else self.n\n",
    "            elif self.n < 0:\n",
    "                self.n, self.d = self.__simp((abs(self.n), abs(number)))\n",
    "                self.n = -self.n if number > 0 else self.n\n",
    "        return self.d\n",
    "\n",
    "    def __neg__(self):\n",
    "        return Fraction(-self.n, self.d)\n",
    "\n",
    "    def __add__(self, other):\n",
    "        return Fraction(self.n * other.d + other.n * self.d, self.d * other.d)\n",
    "\n",
    "    def __iadd__(self, other):\n",
    "        self.n, self.d = self.__simp((self.n * other.d + other.n * self.d, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __sub__(self, other):\n",
    "        return Fraction(self.n * other.d - other.n * self.d, self.d * other.d)\n",
    "\n",
    "    def __isub__(self, other):\n",
    "        self.n, self.d = self.__simp((self.n * other.d - other.n * self.d, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __mul__(self, other):\n",
    "        return Fraction(self.n * other.n, self.d * other.d)\n",
    "\n",
    "    def __imul__(self, other):\n",
    "        self.n, self.d = self.__simp((self.n * other.n, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __truediv__(self, other):\n",
    "        return Fraction(self.n * other.d, self.d * other.n)\n",
    "\n",
    "    def __itruediv__(self, other):\n",
    "        self.n, self.d = self.__simp((self.n * other.d, self.d * other.n))\n",
    "        return self\n",
    "\n",
    "    def reverse(self):\n",
    "        self.n, self.d = self.__simp((self.d, self.n))\n",
    "        return self\n",
    "\n",
    "    def __gt__(self, other):\n",
    "        return self.n / self.d > other.n / other.d\n",
    "\n",
    "    def __ge__(self, other):\n",
    "        return self.n / self.d >= other.n / other.d\n",
    "\n",
    "    def __lt__(self, other):\n",
    "        return self.n / self.d < other.n / other.d\n",
    "\n",
    "    def __le__(self, other):\n",
    "        return self.n / self.d <= other.n / other.d\n",
    "\n",
    "    def __eq__(self, other):\n",
    "        return self.n / self.d == other.n / other.d\n",
    "\n",
    "    def __ne__(self, other):\n",
    "        return self.n / self.d != other.n / other.d\n",
    "\n",
    "    def __str__(self):\n",
    "        return f\"{self.n}/{self.d}\"\n",
    "\n",
    "    def __repr__(self):\n",
    "        return f\"Fraction('{self.n}/{self.d}')\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Задание I\n",
    "class Fraction:\n",
    "\n",
    "    def __simp(self, coords):\n",
    "        if len(coords) == 1:\n",
    "            coords += (1,)\n",
    "        a, b = coords[0], coords[1]\n",
    "        while b:\n",
    "            a, b = b, a % b\n",
    "        return coords[0] // a, coords[1] // a\n",
    "\n",
    "    def __init__(self, *args):\n",
    "        if isinstance(args[0], str):\n",
    "            self.n, self.d = self.__simp(tuple(map(int, args[0].split('/'))))\n",
    "        else:\n",
    "            self.n, self.d = self.__simp(args)\n",
    "\n",
    "    def numerator(self, number=0):\n",
    "        if number:\n",
    "            if self.n > 0:\n",
    "                self.n, self.d = self.__simp((abs(number), self.d))\n",
    "                self.n = -self.n if number < 0 else self.n\n",
    "            elif self.n < 0:\n",
    "                self.n, self.d = self.__simp((abs(number), self.d))\n",
    "                self.n = -self.n if number > 0 else self.n\n",
    "        return abs(self.n)\n",
    "\n",
    "    def denominator(self, number=0):\n",
    "        if number:\n",
    "            if self.n > 0:\n",
    "                self.n, self.d = self.__simp((self.n, abs(number)))\n",
    "                self.n = -self.n if number < 0 else self.n\n",
    "            elif self.n < 0:\n",
    "                self.n, self.d = self.__simp((abs(self.n), abs(number)))\n",
    "                self.n = -self.n if number > 0 else self.n\n",
    "        return self.d\n",
    "\n",
    "    def __neg__(self):\n",
    "        return Fraction(-self.n, self.d)\n",
    "\n",
    "    def __add__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return Fraction(self.n * other.d + other.n * self.d, self.d * other.d)\n",
    "\n",
    "    def __iadd__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        self.n, self.d = self.__simp((self.n * other.d + other.n * self.d, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __sub__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return Fraction(self.n * other.d - other.n * self.d, self.d * other.d)\n",
    "\n",
    "    def __isub__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        self.n, self.d = self.__simp((self.n * other.d - other.n * self.d, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __mul__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return Fraction(self.n * other.n, self.d * other.d)\n",
    "\n",
    "    def __imul__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        self.n, self.d = self.__simp((self.n * other.n, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __truediv__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return Fraction(self.n * other.d, self.d * other.n)\n",
    "\n",
    "    def __itruediv__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        self.n, self.d = self.__simp((self.n * other.d, self.d * other.n))\n",
    "        return self\n",
    "\n",
    "    def reverse(self):\n",
    "        self.n, self.d = self.__simp((self.d, self.n))\n",
    "        return self\n",
    "\n",
    "    def __gt__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return self.n / self.d > other.n / other.d\n",
    "\n",
    "    def __ge__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return self.n / self.d >= other.n / other.d\n",
    "\n",
    "    def __lt__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return self.n / self.d < other.n / other.d\n",
    "\n",
    "    def __le__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return self.n / self.d <= other.n / other.d\n",
    "\n",
    "    def __eq__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return self.n / self.d == other.n / other.d\n",
    "\n",
    "    def __ne__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return self.n / self.d != other.n / other.d\n",
    "\n",
    "    def __str__(self):\n",
    "        return f\"{self.n}/{self.d}\"\n",
    "\n",
    "    def __repr__(self):\n",
    "        return f\"Fraction('{self.n}/{self.d}')\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Задание J\n",
    "class Fraction:\n",
    "\n",
    "    def __simp(self, coords):\n",
    "        if len(coords) == 1:\n",
    "            coords += (1,)\n",
    "        a, b = coords[0], coords[1]\n",
    "        while b:\n",
    "            a, b = b, a % b\n",
    "        return coords[0] // a, coords[1] // a\n",
    "\n",
    "    def __init__(self, *args):\n",
    "        if isinstance(args[0], str):\n",
    "            self.n, self.d = self.__simp(tuple(map(int, args[0].split('/'))))\n",
    "        else:\n",
    "            self.n, self.d = self.__simp(args)\n",
    "\n",
    "    def numerator(self, number=0):\n",
    "        if number:\n",
    "            if self.n > 0:\n",
    "                self.n, self.d = self.__simp((abs(number), self.d))\n",
    "                self.n = -self.n if number < 0 else self.n\n",
    "            elif self.n < 0:\n",
    "                self.n, self.d = self.__simp((abs(number), self.d))\n",
    "                self.n = -self.n if number > 0 else self.n\n",
    "        return abs(self.n)\n",
    "\n",
    "    def denominator(self, number=0):\n",
    "        if number:\n",
    "            if self.n > 0:\n",
    "                self.n, self.d = self.__simp((self.n, abs(number)))\n",
    "                self.n = -self.n if number < 0 else self.n\n",
    "            elif self.n < 0:\n",
    "                self.n, self.d = self.__simp((abs(self.n), abs(number)))\n",
    "                self.n = -self.n if number > 0 else self.n\n",
    "        return self.d\n",
    "\n",
    "    def __neg__(self):\n",
    "        return Fraction(-self.n, self.d)\n",
    "\n",
    "    def __add__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return Fraction(self.n * other.d + other.n * self.d, self.d * other.d)\n",
    "\n",
    "    def __radd__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return Fraction(self.n * other.d + other.n * self.d, self.d * other.d)\n",
    "\n",
    "    def __iadd__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        self.n, self.d = self.__simp((self.n * other.d + other.n * self.d, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __sub__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return Fraction(self.n * other.d - other.n * self.d, self.d * other.d)\n",
    "\n",
    "    def __rsub__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return Fraction(other.n * self.d - self.n * other.d, self.d * other.d)\n",
    "\n",
    "    def __isub__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        self.n, self.d = self.__simp((self.n * other.d - other.n * self.d, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __mul__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return Fraction(self.n * other.n, self.d * other.d)\n",
    "\n",
    "    def __rmul__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return Fraction(self.n * other.n, self.d * other.d)\n",
    "\n",
    "    def __imul__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        self.n, self.d = self.__simp((self.n * other.n, self.d * other.d))\n",
    "        return self\n",
    "\n",
    "    def __truediv__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return Fraction(self.n * other.d, self.d * other.n)\n",
    "\n",
    "    def __rtruediv__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return Fraction(self.d * other.n, self.n * other.d)\n",
    "\n",
    "    def __itruediv__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        self.n, self.d = self.__simp((self.n * other.d, self.d * other.n))\n",
    "        return self\n",
    "\n",
    "    def reverse(self):\n",
    "        self.n, self.d = self.__simp((self.d, self.n))\n",
    "        return self\n",
    "\n",
    "    def __gt__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return self.n / self.d > other.n / other.d\n",
    "\n",
    "    def __ge__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return self.n / self.d >= other.n / other.d\n",
    "\n",
    "    def __lt__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return self.n / self.d < other.n / other.d\n",
    "\n",
    "    def __le__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return self.n / self.d <= other.n / other.d\n",
    "\n",
    "    def __eq__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return self.n / self.d == other.n / other.d\n",
    "\n",
    "    def __ne__(self, other):\n",
    "        other = other if isinstance(other, Fraction) else Fraction(other)\n",
    "        return self.n / self.d != other.n / other.d\n",
    "\n",
    "    def __str__(self):\n",
    "        return f\"{self.n}/{self.d}\"\n",
    "\n",
    "    def __repr__(self):\n",
    "        return f\"Fraction('{self.n}/{self.d}')\""
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
